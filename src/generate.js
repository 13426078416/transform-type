import { configFileName, defaultConfig } from "./config";
import path, { resolve } from "path";
import chalk from "chalk";
import fs from "fs-extra";
import inquirer from "inquirer";
import {
  dataTypeGenerator,
  getDataTypeName,
  jsonSchemaToType,
  prettierContent,
} from "./unit";
import jsonSchemaGenerator from "json-schema-generator";
import dedent from "dedent";

export class Generate {
  constructor() {
    this.configFilName = configFileName;
    this.path = process.cwd();
    this.filePath = path.resolve(this.path, this.configFilName);
    this.config = this.resolveConfig();
  }
  async init() {
    const existOutPutDirList = fs.existsSync(this.config.output);
    const outPath = `${this.path}${this.config.output}`;
    if (existOutPutDirList) {
      const { action } = await inquirer.prompt([
        {
          name: "action",
          type: "list",
          message: `output dir ${chalk.cyan(
            outPath
          )} already  exists. Pick an action:`,
          choices: [
            { name: "Merge", value: "merge" },
            { name: "Overwrite", value: "overwrite" },
            { name: "Cancel", value: false },
          ],
        },
      ]);
      if (!action) return;
      if (action === "overwrite") {
        console.log(`\nRemoving ${chalk.cyan(outPath)}...`);
        fs.removeSync(outPath);
      }
    }
    const outputFiles = await this.generate();
  }
  async generate() {
    const entryDir = `${this.path}${this.config.entry}`;
    const outDir = `${this.path}${this.config.output}`;
    let files;
    try {
      files = await fs.readdirSync(entryDir);
    } catch (error) {
      console.error(error);
    }
    if (!files) {
      console.error("File directory does not exist");
      return;
    }
    const getType = async (jsonSchema, data) => {
      return new Promise(async (resolve) => {
        const dataType = await jsonSchemaToType(
          jsonSchema,
          data.outDataTypeName
        );
        resolve({ ...data, dataType });
      });
    };
    const promiseFun = () => {
      return files.reduce((res, childPath) => {
        const childFilePath = path.resolve(entryDir, childPath);
        const content = require(childFilePath);
        Object.entries(content).forEach(([key, value]) => {
          const outFileName = childPath.replace(/\.[A-z0-9]+$/, "");
          const outDataTypeName = getDataTypeName(key);
          const jsonSchema = dataTypeGenerator(jsonSchemaGenerator(value));
          res.push(
            getType(jsonSchema, {
              outFileName,
              outDataTypeName,
            })
          );
        });
        return res;
      }, []);
    };
    let data;
    try {
      data = await Promise.all(promiseFun());
    } catch (error) {
      console.error(error);
    }
    if (!data) console.error("Failed to get type file correctly");
    const newData = data.reduce((res, cur) => {
      if (!res[cur.outFileName]) res[cur.outFileName] = [];
      res[cur.outFileName].push(cur.dataType);
      return res;
    }, {});
    Object.entries(newData).forEach(([key, value]) => {
      const filePath = path.resolve(`${outDir}`, `${key}.ts`);
      //   if (!fs.existsSync(filePath)) fs.createFileSync(filePath);
      const finalContent = `${dedent`
        /* eslint-disable */

        /* This file generated by transform-type, do not modify it!!! */

        /* prettier-ignore-start */
        // @ts-ignore
        export namespace ${key}{
            ${value.join("\n")}
        }
        /* prettier-ignore-end */
        `}\n`;
      fs.outputFile(filePath, prettierContent(finalContent));
    });
  }
  resolveConfig() {
    let config = require(this.filePath);
    if (!config) {
      console.error(
        `Error load ${chalk.bold(
          `${this.configFilName}`
        )}: should export an object \n`
      );
      config = defaultConfig;
    }
    return config;
  }
}
